# Architecture Design Guidelines

**버전:** 1.0.0
**생성일:** 2025-10-29
**목적:** 프론트엔드 아키텍처 설계를 위한 기술적 규칙 및 가이드라인

---

## 1. 기술 스택 선정 규칙

### 1.1 기본 원칙

#### 1.1.1 기존 프로젝트 우선
- **신규 프로젝트가 아닌 경우**, 프로젝트의 기존 기술 스택을 최우선으로 따른다
- 사용자가 명시적으로 기술 변경을 요청하거나, 기존 스택으로 요구사항을 충족할 수 없는 경우에만 새로운 기술을 고려한다

#### 1.1.2 기술 변경 vs 기술 추가
- **기술 추가**: 기존 스택에 새로운 라이브러리를 추가하는 것
  - 예: 프로젝트에 날짜 처리를 위해 `date-fns` 추가
  - 검증: 호환성, 번들 크기, 학습 곡선

- **기술 변경**: 기존에 사용 중인 기술을 다른 것으로 교체하는 것
  - 예: Redux → Zustand, Webpack → Vite
  - **변경은 추가보다 훨씬 더 많은 검증이 필요**함
  - 마이그레이션 비용, 기존 코드 영향도, 팀 학습 비용 등을 신중히 평가해야 함

#### 1.1.3 기술 변경 시 필수 검증 항목
기존 기술을 변경하려면 다음 모든 항목을 충족해야 한다:

1. **변경 필요성**
   - 기존 기술로 요구사항 충족이 불가능한가?
   - 성능, 유지보수성, 개발 생산성에 명확한 개선이 있는가?

2. **마이그레이션 비용**
   - 기존 코드 수정 범위는 어느 정도인가?
   - 개발 일정에 미치는 영향은?
   - 테스트 및 검증 비용은?

3. **팀 영향도**
   - 팀이 새로운 기술을 학습하는 데 필요한 시간은?
   - 기술 문서 및 가이드가 충분한가?

4. **리스크 평가**
   - 마이그레이션 중 발생 가능한 버그 및 이슈는?
   - 롤백 계획이 있는가?

5. **사용자 승인**
   - 사용자가 명시적으로 변경을 요청했거나 승인했는가?

### 1.2 기술 선정 프로세스

#### 단계 1: 현재 프로젝트 기술 스택 파악
1. `package.json`, `vite.config.ts`, `tsconfig.json` 등을 확인
2. 현재 사용 중인 주요 라이브러리 및 버전 파악
3. 기존 아키텍처 문서가 있다면 참조

#### 단계 2: 요구사항 분석
1. PRD의 기능 및 제약사항 확인
2. 기존 기술 스택으로 충족 가능한지 판단
3. 추가 라이브러리가 필요한 경우 식별

#### 단계 3: 기술 선정
1. **기존 스택 활용**: 가능하면 기존 기술 사용
2. **기술 추가**: 새로운 기능에 필요한 라이브러리만 추가
3. **기술 변경**: 필수 검증 항목을 모두 통과한 경우에만 고려

#### 단계 4: 문서화
- 선택한 기술과 근거 명시
- 선택하지 않은 대안과 이유 기록
- 기존 기술을 변경한 경우, 마이그레이션 계획 포함

---

## 2. 아키텍처 설계 원칙

### 2.1 계층 분리 (Layered Architecture)

프론트엔드 애플리케이션은 다음 3개 계층으로 구성한다:

```
┌─────────────────────────────────────────┐
│        Presentation Layer               │
│  (Components, Pages, UI Logic)          │
├─────────────────────────────────────────┤
│       Business Logic Layer              │
│  (Hooks, Services, State Management)    │
├─────────────────────────────────────────┤
│           Data Layer                    │
│  (API, LocalStorage, Cache)             │
└─────────────────────────────────────────┘
```

#### 2.1.1 Presentation Layer
- **책임**: UI 렌더링, 사용자 입력 처리, UI 상태 관리
- **구성요소**: Pages, Components, Layouts
- **제약**: 비즈니스 로직을 포함하지 않음, Data Layer에 직접 접근하지 않음

#### 2.1.2 Business Logic Layer
- **책임**: 비즈니스 로직 처리, 데이터 가공, 전역 상태 관리
- **구성요소**: Custom Hooks, Services, Store
- **제약**: UI 렌더링을 담당하지 않음

#### 2.1.3 Data Layer
- **책임**: 외부 데이터 소스와의 통신, 캐싱, 로컬 저장
- **구성요소**: API Client, Storage, Cache
- **제약**: UI 및 비즈니스 로직을 포함하지 않음

### 2.2 모듈화 및 관심사 분리

1. **단일 책임 원칙**: 각 모듈은 하나의 명확한 책임만 가진다
2. **느슨한 결합 (Loose Coupling)**: 모듈 간 의존성을 최소화한다
3. **높은 응집도 (High Cohesion)**: 관련된 기능은 한 곳에 모은다

### 2.3 확장 가능성 (Scalability)

- 새로운 기능 추가 시 기존 코드 수정을 최소화
- 기능별로 독립적인 모듈 구조 유지
- 플러그인 또는 확장 가능한 구조 선호

### 2.4 테스트 가능성 (Testability)

- 의존성 주입 패턴 사용
- 순수 함수 우선 사용
- 사이드 이펙트 격리

---

## 3. 컴포넌트 설계 규칙

### 3.1 컴포넌트 분류

#### 3.1.1 페이지 컴포넌트 (Pages)
- **위치**: `src/pages/`
- **특징**: 라우팅과 직접 연결
- **책임**: 페이지 레벨 상태 관리, 하위 컴포넌트 조합
- **명명**: `[Name]Page.tsx`

#### 3.1.2 기능 컴포넌트 (Features)
- **위치**: `src/features/[feature]/components/`
- **특징**: 특정 기능 담당
- **책임**: 기능별 비즈니스 로직 포함
- **명명**: `[FeatureName].tsx`

#### 3.1.3 공통 컴포넌트 (Common)
- **위치**: `src/components/common/`
- **특징**: 재사용 가능한 범용 UI
- **책임**: UI 렌더링, 기본 상호작용
- **명명**: `[ComponentName].tsx`

### 3.2 컴포넌트 설계 원칙

1. **단일 책임**: 하나의 컴포넌트는 하나의 역할만
2. **Props 최소화**: 필요한 Props만 전달
3. **합성 우선**: 상속보다 합성 사용
4. **컨테이너/프레젠테이셔널 분리**: 필요시 로직과 UI 분리

### 3.3 Props 설계 규칙

- 명확한 타입 정의 (TypeScript Interface)
- 선택적 Props는 기본값 제공
- Props drilling을 3단계 이상 하지 않음 (Context 또는 상태 관리 라이브러리 사용)

---

## 4. 상태 관리 설계 규칙

### 4.1 상태 분류

#### 4.1.1 전역 상태 (Global State)
- **특징**: 여러 컴포넌트에서 공유
- **예시**: 사용자 인증 정보, 테마 설정, 전역 알림
- **관리**: Redux, Zustand, Recoil 등

#### 4.1.2 로컬 상태 (Local State)
- **특징**: 컴포넌트 내부에서만 사용
- **예시**: 폼 입력값, 모달 열림/닫힘, UI 토글
- **관리**: `useState`, `useReducer`

#### 4.1.3 서버 상태 (Server State)
- **특징**: 서버로부터 가져온 데이터
- **예시**: API 응답 데이터, 캐시된 데이터
- **관리**: React Query, SWR, RTK Query 등

### 4.2 상태 관리 원칙

1. **상태는 가능한 한 가까운 곳에 위치**: 전역 상태를 남발하지 않음
2. **단방향 데이터 흐름**: 상태 업데이트 흐름을 명확히
3. **불변성 유지**: 상태를 직접 변경하지 않고 새로운 객체 생성
4. **정규화된 상태**: 중첩된 데이터는 정규화하여 관리

---

## 5. 데이터 흐름 설계 규칙

### 5.1 API 통신 패턴

#### 5.1.1 API 호출 흐름
```
Component → Custom Hook → Service → API Client → Server
                                              ↓
Component ← Custom Hook ← Service ← Response ←┘
```

#### 5.1.2 에러 핸들링 전략

| 에러 유형 | 처리 방법 |
|---------|----------|
| 네트워크 에러 | 재시도 로직 (최대 3회) + 사용자 알림 |
| 4xx 에러 | 에러 메시지 표시, 필요 시 로그인 페이지로 리다이렉트 |
| 5xx 에러 | 폴백 UI 표시 + 에러 로깅 |

#### 5.1.3 재시도 로직
- 네트워크 에러 또는 timeout 발생 시 자동 재시도
- 지수 백오프(Exponential Backoff) 사용
- 최대 재시도 횟수: 3회

### 5.2 캐싱 전략

| 데이터 유형 | 캐싱 방법 | 유효 기간 | 용도 |
|-----------|----------|----------|------|
| 사용자 정보 | LocalStorage | 세션 유지 | 인증 정보 유지 |
| 일시적 설정 | SessionStorage | 탭 닫을 때까지 | 임시 설정값 |
| API 응답 | 메모리 캐시 (React Query 등) | 5-10분 | 반복 요청 최적화 |

### 5.3 데이터 동기화

- **낙관적 업데이트(Optimistic Update)**: UI를 먼저 업데이트하고 서버 응답을 기다림
- **충돌 해결**: 서버 응답이 실패하면 UI를 이전 상태로 롤백
- **실시간 동기화**: 필요 시 WebSocket 또는 Server-Sent Events 사용

---

## 6. 성능 최적화 규칙

### 6.1 렌더링 최적화

| 기법 | 적용 대상 | 사용 시점 |
|-----|----------|----------|
| `React.memo` | 순수 컴포넌트 | Props 변경이 적고, 렌더링 비용이 큰 경우 |
| `useMemo` | 계산 비용이 큰 값 | 의존성이 자주 변하지 않는 경우 |
| `useCallback` | 콜백 함수 | 자식 컴포넌트에 Props로 전달되는 함수 |

### 6.2 코드 분할 (Code Splitting)

- **라우트 기반 분할**: 각 페이지를 별도 청크로 분리
- **컴포넌트 기반 분할**: 크기가 크거나 조건부로 렌더링되는 컴포넌트 분리
- **라이브러리 분할**: 큰 라이브러리는 Dynamic Import로 로드

```typescript
// 예시: 라우트 기반 코드 분할
const HeavyComponent = lazy(() => import('./HeavyComponent'));
```

### 6.3 번들 최적화

1. **Tree Shaking**: 사용하지 않는 코드 제거
2. **Minification**: 프로덕션 빌드 시 코드 압축
3. **청크 분할**: Vendor, Common, Route별로 청크 분리

### 6.4 이미지 최적화

- Lazy Loading 적용 (`loading="lazy"`)
- WebP 또는 AVIF 포맷 사용
- 반응형 이미지 (`srcset`, `sizes`)
- 적절한 이미지 크기 사용 (불필요하게 큰 이미지 금지)

---

## 7. 보안 및 품질 가이드라인

### 7.1 보안 고려사항

#### 7.1.1 XSS (Cross-Site Scripting) 방어
- 사용자 입력을 항상 이스케이프 처리
- `dangerouslySetInnerHTML` 사용 금지 (불가피한 경우 sanitize 라이브러리 사용)
- Content Security Policy (CSP) 설정

#### 7.1.2 CSRF (Cross-Site Request Forgery) 방어
- CSRF 토큰 사용
- SameSite 쿠키 속성 설정

#### 7.1.3 민감 데이터 처리
- API 키, 비밀번호 등을 코드에 하드코딩하지 않음
- 환경 변수 사용 (`.env` 파일, 버전 관리에서 제외)
- 민감 데이터는 HTTPS로만 전송

### 7.2 접근성 (A11y)

- **Semantic HTML 사용**: `<button>`, `<nav>`, `<main>` 등
- **ARIA 레이블 추가**: 스크린 리더를 위한 레이블
- **키보드 네비게이션 지원**: Tab, Enter, Esc 키 지원
- **색상 대비 확보**: WCAG AA 기준 준수 (최소 4.5:1)

### 7.3 코드 품질

1. **타입 안정성**: TypeScript 사용, `any` 타입 최소화
2. **린팅**: ESLint 규칙 준수
3. **포매팅**: Prettier 자동 포매팅
4. **에러 바운더리**: 컴포넌트 트리의 에러를 catch하는 Error Boundary 사용

---

## 8. 디렉토리 구조 규칙

### 8.1 표준 디렉토리 구조

```
src/
├── assets/              # 정적 리소스 (이미지, 폰트 등)
├── components/          # 공통 컴포넌트
│   ├── common/          # 범용 UI 컴포넌트
│   └── layout/          # 레이아웃 컴포넌트
├── features/            # 기능별 모듈
│   └── [feature]/
│       ├── components/  # 기능별 컴포넌트
│       ├── hooks/       # 기능별 커스텀 훅
│       └── types/       # 기능별 타입 정의
├── hooks/               # 공통 커스텀 훅
├── pages/               # 페이지 컴포넌트
├── services/            # 비즈니스 로직, API 호출
├── store/               # 전역 상태 관리
├── types/               # 공통 타입 정의
├── utils/               # 유틸리티 함수
├── styles/              # 전역 스타일
├── App.tsx              # 루트 컴포넌트
└── main.tsx             # 진입점
```

### 8.2 파일 명명 규칙

| 파일 유형 | 명명 규칙 | 예시 |
|---------|----------|------|
| 컴포넌트 | PascalCase | `Button.tsx`, `UserProfile.tsx` |
| 훅 | camelCase + `use` 접두사 | `useAuth.ts`, `useFetch.ts` |
| 서비스 | camelCase + `Service` 접미사 | `authService.ts`, `apiService.ts` |
| 유틸리티 | camelCase | `formatDate.ts`, `validators.ts` |
| 타입/인터페이스 | PascalCase + `Type`/`Interface` | `UserType.ts`, `ApiResponse.ts` |

---

**이 문서는 프론트엔드 아키텍처 설계 시 준수해야 하는 기술적 규칙과 가이드라인을 정의한다.**
